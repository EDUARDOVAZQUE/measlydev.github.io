<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Junimo Recolector - Controles Mejorados</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Silkscreen&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
      font-family: 'Silkscreen', cursive;
      box-sizing: border-box;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      width: 100vw;
    }

    *,
    *::before,
    *::after {
      box-sizing: inherit;
    }

    /* --- Viewport sin borde externo --- */
    #viewport {
      position: relative;
      width: 100%;
      height: 100%;
      max-width: 1200px;
      max-height: 800px;
      box-sizing: border-box;
      overflow: hidden;
      aspect-ratio: 1200 / 800;
    }

    /* --- Contenedor del juego con borde más visible --- */
    #game-world {
      position: absolute;
      top: 50px;
      left: 20px;
      width: 1100px;
      height: 725px;
      overflow: hidden;
      transform: translate(0, 0);
      transform-origin: top left;
      /* Borde más grueso y con efecto de profundidad */
      border: 2px solid #a8a8a8;
      box-sizing: border-box;
    }

    #game-world>*:not(#instructions) {
      position: absolute;
    }

    /* --- Elementos del Juego --- */
    .sprite,
    #fruit,
    #junimo-hut,
    .enemy-slime {
      position: absolute;
      image-rendering: pixelated;
      background-repeat: no-repeat;
    }

    /* --- Junimo (Personaje) --- */
    .sprite {
      width: 64px;
      height: 64px;
      background-image: url('img/Junimo.png');
      background-size: 512px 512px;
      background-position-y: -64px;
      filter: hue-rotate(1000deg) saturate(11);
      animation: idle 1s steps(8) infinite;
      z-index: 10;
      transform: translate(-50%, -50%);
    }

    .walking-down {
      background-position-y: 0px;
    }

    .walking-right {
      background-position-y: -128px;
    }

    .walking-up {
      background-position-y: -256px;
    }

    @keyframes idle {
      from {
        background-position-x: 0px;
      }

      to {
        background-position-x: -512px;
      }
    }

    @keyframes walk {
      from {
        background-position-x: 0px;
      }

      to {
        background-position-x: -512px;
      }
    }

    .walking {
      animation: walk 0.5s steps(8) infinite;
    }

    /* --- Enemigo Slime con brillo correcto --- */
    .enemy-slime {
      width: 60px;
      height: 45px;
      background-image: url('img/slime.png');
      background-size: 250px 100px;
      background-position-y: 0px;
      animation: slimeIdle 1.2s steps(4) infinite;
      z-index: 8;
      transform: translate(-50%, -50%);
      filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.8)) drop-shadow(0 0 3px rgba(255, 255, 255, 0.4));
      transition: filter 0.2s ease-out;
    }

    @keyframes slimeIdle {
      from {
        background-position-x: 0px;
      }

      to {
        background-position-x: -256px;
      }
    }

    .enemy-moving {
      animation: slimeMove 0.8s steps(4) infinite;
      /* Intensificar el brillo cuando se mueve */
      filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.8)) drop-shadow(0 0 3px rgba(255, 255, 255, 0.4)) !important;
    }

    @keyframes slimeMove {
      from {
        background-position-x: 0px;
      }

      to {
        background-position-x: -256px;
      }
    }

    .enemy-slime.moving-left {
      transform: translate(-50%, -50%) scaleX(-1);
    }

    .enemy-slime.moving-right {
      transform: translate(-50%, -50%) scaleX(1);
    }

    /* --- Fruta --- */
    #fruit {
      width: 53.2px;
      height: 55.3px;
      background-image: url('img/fruta.png');
      background-size: 320px 440px;
      background-position: -53.3px -55.3px;
      z-index: 5;
      transform: translate(-50%, -50%);
      animation: fruitGlow 1.5s ease-in-out infinite alternate;
    }

    @keyframes fruitGlow {
      from {
        filter: drop-shadow(0 0 5px rgba(255, 255, 0, 0.5));
      }

      to {
        filter: drop-shadow(0 0 15px rgba(255, 255, 0, 0.9));
      }
    }

    /* --- Casa Junimo --- */
    #junimo-hut {
      width: 95.4px;
      height: 128px;
      background-image: url('img/casa.png');
      background-size: 512px 128px;
      background-position: 0 0;
      transform: translate(-50%, -50%);
      z-index: 6;
    }

    /* --- Barra de UI Unificada --- */
    #unified-ui {
      position: fixed;
      z-index: 200;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 20, 0.9));
      border: 3px solid #a8a8a8;
      border-radius: 1px;
      padding: 10px;
      color: white;
      font-size: 1.2em;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      box-shadow:
        0 0 5px rgba(144, 238, 144, 0.3),
        inset 0 0 1px rgba(144, 238, 144, 0.1);
      backdrop-filter: blur(5px);
    }

    .ui-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 2px 0;
      padding: 5px 0;
      border-bottom: 1px solid rgba(144, 238, 144, 0.3);
    }

    .ui-item:last-child {
      border-bottom: none;
    }

    .ui-label {
      color: #a8a8a8;
      margin-right: 15px;
    }

    .ui-value {
      color: white;
      font-weight: bold;
    }

    /* Barra de progreso mejorada */
    .progress-container {
      display: flex;
      align-items: center;
      gap: 10px;
      width: 100%;
    }

    .progress-bar {
      flex: 1;
      height: 20px;
      background: linear-gradient(90deg, #333, #555);
      border-radius: 10px;
      overflow: hidden;
      border: 2px solid #90EE90;
      box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #90EE90, #32CD32, #90EE90);
      width: 0%;
      transition: width 0.3s ease-out;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(144, 238, 144, 0.5);
    }

    /* --- Instrucciones --- */
    #instructions {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 20px;
      border-radius: 15px;
      text-align: center;
      z-index: 210;
      font-size: 1.2em;
      border: 3px solid #a8a8a8;
      box-shadow: 0 0 10px rgba(144, 238, 144, 0.5);
    }

    #instructions h3 {
      margin-bottom: 15px;
      color: #a8a8a8;
      text-shadow: 0 0 1px rgba(144, 238, 144, 0.8);
    }

    #instructions p {
      margin: 10px 0;
      line-height: 1.4;
    }

    /* --- CONTROLES MÓVILES MEJORADOS --- */
    #mobile-controls {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 0;
      right: 0;
      z-index: 200;
      pointer-events: none;
      transition: opacity 0.3s ease, transform 0.3s ease;
      opacity: 1;
      transform: translateY(0);
    }

    #mobile-controls.hidden {
      opacity: 0 !important;
      transform: translateY(100px) !important;
      pointer-events: none !important;
    }

    /* Switch de control */
    #control-switch {
      position: absolute;
      top: -60px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #a8a8a8;
      border-radius: 20px;
      padding: 8px 15px;
      color: white;
      font-size: 0.9em;
      pointer-events: auto;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #control-toggle {
      position: relative;
      width: 50px;
      height: 25px;
      background: #333;
      border-radius: 15px;
      cursor: pointer;
      transition: background 0.3s;
    }

    #control-toggle.active {
      background: #90EE90;
    }

    #control-toggle::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 21px;
      height: 21px;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s;
    }

    #control-toggle.active::after {
      transform: translateX(25px);
    }

    /* D-pad mejorado */
    #dpad-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      padding: 0 30px;
      pointer-events: auto;
    }

    .dpad-section {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .dpad-section.horizontal {
      flex-direction: row;
      gap: 20px;
    }

    .dpad-button {
      width: 90px;
      height: 90px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.7), rgba(200, 200, 200, 0.7));
      border-radius: 50%;
      border: 3px solid white;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 28px;
      color: white;
      user-select: none;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      transition: all 0.1s;
    }

    .dpad-button:active {
      transform: scale(0.95);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    /* Joystick */
    #joystick-controls {
      display: none;
      justify-content: center;
      align-items: center;
      width: 100%;
      pointer-events: auto;
    }

    #joystick-canvas {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      touch-action: none;
    }

    /* Botón para ocultar/mostrar controles */
    #toggle-controls-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #a8a8a8;
      border-radius: 50%;
      color: white;
      font-size: 20px;
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 201;
      pointer-events: auto;
      cursor: pointer;
      transition: all 0.2s ease;
      user-select: none;
    }

    #toggle-controls-btn:active {
      transform: scale(0.95);
      background: rgba(0, 0, 0, 0.9);
    }

    #toggle-controls-btn.controls-hidden {
      background: rgba(144, 238, 144, 0.8) !important;
      border-color: #90EE90 !important;
    }

    /* --- Pantalla Final --- */
    #game-over-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 250;
      padding: 2rem;
    }

    .hidden {
      display: none !important;
    }

    /* ------------------------------------------------------------------- */
    /* RESPONSIVIDAD DE UI */
    /* ------------------------------------------------------------------- */
    /* Reglas para PC (pantallas grandes) */
    @media (min-width: 769px) {
      body {
        padding-right: 280px;
        /* Espacio para la barra lateral */
        justify-content: flex-start;
        align-items: center;
        padding-left: 20px;
      }

      #unified-ui {
        top: 50%;
        right: 20px;
        transform: translateY(-50%);
        width: 240px;
        flex-direction: column;
      }

      .progress-container {
        flex-direction: column;
        align-items: stretch;
      }

      .progress-bar {
        width: 100%;
        height: 20px;
      }

      .progress-fill {
        width: 0%;
        height: 100%;
      }

    }
      @media (max-width: 768px),
    (max-height: 600px) {
      body {
        padding: 0;
        padding-top: 120px;
        /* Espacio para la barra superior */
        justify-content: center;
        align-items: center;
      }

      #unified-ui {
        top: 15px;
        left: 50%;
        transform: translateX(-50%);
        width: calc(100% - 30px);
        max-width: 400px;
        flex-direction: column;
      }

      .ui-item {
        flex-direction: row;
        justify-content: space-between;
      }

      .progress-container {
        flex-direction: row;
        align-items: center;
      }

      .progress-bar {
        flex: 1;
        height: 15px;
      }

      .progress-fill {
        width: 0%;
        height: 100%;
      }

      #unified-ui {
        font-size: 1em;
        padding: 12px;
      }
    }
      /* EN PC: Mostrar controles móviles pero permitir ocultarlos */
      /*#mobile-controls {
        display: block !important;
      }

      /* EN PC: Mostrar botón de toggle */
      /*#toggle-controls-btn {
        display: flex !important;
      }
    }

    /* Reglas para Móvil (pantallas pequeñas) */
    /*

      /* EN MÓVIL: Mostrar controles móviles siempre */
      /*#mobile-controls {
        display: block !important;
        opacity: 1 !important;
        transform: translateY(0) !important;
        pointer-events: auto !important;
      }

      /* EN MÓVIL: Ocultar botón de toggle */
      /*#toggle-controls-btn {
        display: none !important;
      }

      /* EN MÓVIL: Asegurar que los controles nunca se oculten */
      /*#mobile-controls.hidden {
        opacity: 1 !important;
        transform: translateY(0) !important;
        pointer-events: auto !important;
      }
    }*/
  </style>
</head>

<body>
  <div id="viewport">
    <div id="game-world">
      <div id="junimo-hut"></div>
      <div id="fruit"></div>
      <div class="sprite" id="sprite"></div>
      <div id="instructions">
        <h3>🎮 Instrucciones</h3>
        <p>🏃 Usa WASD o las flechas para moverte</p>
        <p>📱 En móvil: usa los controles táctiles</p>
        <p>🍓 Recoge las frutas y llévalas a la casa</p>
        <p>👾 ¡Evita a los slimes!</p>
        <p>🎯 Objetivo: ¡Completa los 6 niveles!</p>
      </div>
    </div>
  </div>

  <!-- Barra de UI Unificada -->
  <div id="unified-ui">
    <div class="ui-item">
      <span class="ui-label">Score:</span>
      <span class="ui-value" id="score-value">0</span>
    </div>
    <div class="ui-item">
      <span class="ui-label">Nivel:</span>
      <span class="ui-value" id="level-value">1</span>
    </div>
    <div class="ui-item">
      <span class="ui-label">Frutas:</span>
      <div class="progress-container">
        <span class="ui-value" id="fruits-text">0/5</span>
        <div class="progress-bar">
          <div class="progress-fill" id="progress-fill"></div>
        </div>
      </div>
    </div>
  </div>

  <div id="game-over-screen" class="hidden">
    <h1>¡Felicidades!</h1>
    <p>Has completado todos los niveles.<br>¡Gracias por jugar!</p>
    <button id="restart-button"
      style="padding: 10px 20px; font-size: 1.2em; cursor: pointer; margin-top: 20px; border-radius: 8px; border: 2px solid #90EE90; background: linear-gradient(135deg, #333, #555); color: white;">Jugar
      de Nuevo</button>
  </div>

  <!-- Controles Móviles Mejorados -->
  <div id="mobile-controls">
    <!-- Switch de control -->
    <div id="control-switch">
      <span>D-pad</span>
      <div id="control-toggle"></div>
      <span>Joystick</span>
    </div>

    <!-- D-pad mejorado -->
    <div id="dpad-controls">
      <div class="dpad-section">
        <div class="dpad-button" id="up">▲</div>
        <div class="dpad-button" id="down">▼</div>
      </div>
      <div class="dpad-section horizontal">
        <div class="dpad-button" id="left">◀</div>
        <div class="dpad-button" id="right">▶</div>
      </div>
    </div>

    <!-- Joystick -->
    <div id="joystick-controls">
      <canvas id="joystick-canvas" width="200" height="200"></canvas>
    </div>
  </div>

  <!-- Botón para ocultar/mostrar controles -->
  <div id="toggle-controls-btn" title="Ocultar/Mostrar controles">
    👁️
  </div>

  <script>
    // --- Elementos del DOM ---
    const gameWorld = document.getElementById('game-world');
    const viewport = document.getElementById('viewport');
    const sprite = document.getElementById('sprite');
    const fruit = document.getElementById('fruit');
    const hut = document.getElementById('junimo-hut');
    const scoreValue = document.getElementById('score-value');
    const levelValue = document.getElementById('level-value');
    const fruitsText = document.getElementById('fruits-text');
    const gameOverScreen = document.getElementById('game-over-screen');
    const instructions = document.getElementById('instructions');
    const restartButton = document.getElementById('restart-button');
    const progressFill = document.getElementById('progress-fill');

    // --- Configuración del mundo del juego ---
    const WORLD_WIDTH = 1200;
    const WORLD_HEIGHT = 800;
    const WORLD_BORDER_THICKNESS = 20;
    const PLAYABLE_WIDTH = WORLD_WIDTH - (WORLD_BORDER_THICKNESS * 2);
    const PLAYABLE_HEIGHT = WORLD_HEIGHT - (WORLD_BORDER_THICKNESS * 2);
    let currentViewportWidth = 0;
    let currentViewportHeight = 0;
    let scaleRatio = 1;

    // --- Estado del Juego ---
    let playerX;
    let playerY;
    const speed = 5;
    let score = 0;
    let level = 1;
    let fruitsCollectedInLevel = 0;
    const fruitToNextLevel = 5;
    let hasFruit = false;
    let gameOver = false;
    let gameStarted = false;
    let cameraX = 0;
    let cameraY = 0;
    let totalScore = 0;

    // --- Slimes ---
    const slimes = [];
    const maxSlimes = 6;
    const baseEnemySpeed = 1.5;
    const speedIncreasePerLevel = 0.15;

    // Colores para los slimes (filtros hue-rotate)
    const slimeColors = [
      'hue-rotate(0deg) saturate(2) drop-shadow(0 0 8px rgba(255, 100, 100, 0.8)) drop-shadow(0 0 15px rgba(255, 100, 100, 0.4))',
      'hue-rotate(60deg) saturate(2) drop-shadow(0 0 8px rgba(100, 255, 100, 0.8)) drop-shadow(0 0 15px rgba(100, 255, 100, 0.4))',
      'hue-rotate(120deg) saturate(2) drop-shadow(0 0 8px rgba(100, 100, 255, 0.8)) drop-shadow(0 0 15px rgba(100, 100, 255, 0.4))',
      'hue-rotate(180deg) saturate(2) drop-shadow(0 0 8px rgba(100, 255, 255, 0.8)) drop-shadow(0 0 15px rgba(100, 255, 255, 0.4))',
      'hue-rotate(240deg) saturate(2) drop-shadow(0 0 8px rgba(255, 100, 255, 0.8)) drop-shadow(0 0 15px rgba(255, 100, 255, 0.4))',
      'hue-rotate(300deg) saturate(2) drop-shadow(0 0 8px rgba(255, 255, 100, 0.8)) drop-shadow(0 0 15px rgba(255, 255, 100, 0.4))'
    ];

    // Definir las 8 secciones de patrulla
    const patrolSections = [];
    const sectionWidth = PLAYABLE_WIDTH / 4;
    const sectionHeight = PLAYABLE_HEIGHT / 2;
    for (let row = 0; row < 2; row++) {
      for (let col = 0; col < 4; col++) {
        patrolSections.push({
          minX: WORLD_BORDER_THICKNESS + col * sectionWidth,
          maxX: WORLD_BORDER_THICKNESS + (col + 1) * sectionWidth,
          minY: WORLD_BORDER_THICKNESS + row * sectionHeight,
          maxY: WORLD_BORDER_THICKNESS + (row + 1) * sectionHeight
        });
      }
    }

    const keysPressed = {};
    let lastDirection = 'down';

    // --- Función para detectar si es dispositivo táctil ---
    function isTouchDevice() {
      return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    }

    // --- Variables para controles móviles ---
    let isDpadMode = true;
    let joystickActive = false;
    let joystickX = 0;
    let joystickY = 0;
    // Eliminar esta línea:
    // let controlsVisible = true;

    // Eliminar completamente esta función ya que no se usa
    // function toggleControlsVisibility() { ... }

    // --- Comunicación con la página principal ---
    function updateParentScore() {
      totalScore = score;
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({
          type: 'GAME_SCORE_UPDATE',
          totalScore: totalScore
        }, '*');
      }
    }

    function notifyGameWin() {
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({
          type: 'GAME_WIN'
        }, '*');
      }
    }

    // --- Inicializar posiciones ---
    function initializeGame() {
      const hutWidth = parseFloat(getComputedStyle(hut).width);
      const hutHeight = parseFloat(getComputedStyle(hut).height);
      hut.style.left = `${WORLD_WIDTH / 2}px`;
      hut.style.top = `${WORLD_HEIGHT / 2}px`;

      playerX = WORLD_WIDTH / 2;
      playerY = (WORLD_HEIGHT / 2) + (hutHeight / 2) + (64 / 2) + 10;

      sprite.style.left = `${playerX}px`;
      sprite.style.top = `${playerY}px`;

      addSlime();
      spawnFruit();
      updateScalingAndCamera();
      updateUI();
    }

    function spawnFruit() {
      const margin = 80 + WORLD_BORDER_THICKNESS;
      const randomX = Math.random() * (PLAYABLE_WIDTH - margin * 2) + margin;
      const randomY = Math.random() * (PLAYABLE_HEIGHT - margin * 2) + margin;

      fruit.style.left = `${randomX}px`;
      fruit.style.top = `${randomY}px`;
      fruit.style.display = 'block';
    }

    function updateScalingAndCamera() {
      currentViewportWidth = viewport.offsetWidth;
      currentViewportHeight = viewport.offsetHeight;
      scaleRatio = Math.min(currentViewportWidth / WORLD_WIDTH, currentViewportHeight / WORLD_HEIGHT);

      cameraX = playerX - (currentViewportWidth / scaleRatio) / 2;
      cameraY = playerY - (currentViewportHeight / scaleRatio) / 2;

      cameraX = Math.max(WORLD_BORDER_THICKNESS, Math.min(cameraX, WORLD_WIDTH - (currentViewportWidth / scaleRatio) - WORLD_BORDER_THICKNESS));
      cameraY = Math.max(WORLD_BORDER_THICKNESS, Math.min(cameraY, WORLD_HEIGHT - (currentViewportHeight / scaleRatio) - WORLD_BORDER_THICKNESS));

      gameWorld.style.transform = `scale(${scaleRatio}) translate(${-cameraX}px, ${-cameraY}px)`;
    }

    function checkCollision(obj1X, obj1Y, obj1W, obj1H, obj2X, obj2Y, obj2W, obj2H) {
      const scaleFactor = 0.1;
      const reducedW = obj2W * scaleFactor;
      const reducedH = obj2H * scaleFactor;

      const obj1Left = obj1X - obj1W / 2;
      const obj1Right = obj1X + obj1W / 2;
      const obj1Top = obj1Y - obj1H / 2;
      const obj1Bottom = obj1Y + obj1H / 2;

      const obj2Left = obj2X - reducedW / 2;
      const obj2Right = obj2X + reducedW / 2;
      const obj2Top = obj2Y - reducedH / 2;
      const obj2Bottom = obj2Y + reducedH / 2;

      return obj1Left < obj2Right &&
        obj1Right > obj2Left &&
        obj1Top < obj2Bottom &&
        obj1Bottom > obj2Top;
    }

    function addSlime() {
      if (slimes.length >= maxSlimes) return;

      const newSlime = document.createElement('div');
      newSlime.classList.add('enemy-slime');
      gameWorld.appendChild(newSlime);

      const colorIndex = slimes.length % slimeColors.length;
      newSlime.style.filter = slimeColors[colorIndex];

      let slimeX, slimeY;
      let validPosition = false;
      const minDistance = 200;

      const preferredSectionIndex = Math.floor(Math.random() * patrolSections.length);
      const preferredSection = patrolSections[preferredSectionIndex];

      while (!validPosition) {
        slimeX = Math.random() * (preferredSection.maxX - preferredSection.minX) + preferredSection.minX;
        slimeY = Math.random() * (preferredSection.maxY - preferredSection.minY) + preferredSection.minY;

        const distPlayer = Math.sqrt(Math.pow(slimeX - playerX, 2) + Math.pow(slimeY - playerY, 2));
        const hutX = parseFloat(hut.style.left);
        const hutY = parseFloat(hut.style.top);
        const distHut = Math.sqrt(Math.pow(slimeX - hutX, 2) + Math.pow(slimeY - hutY, 2));

        if (distPlayer > minDistance && distHut > minDistance) {
          validPosition = true;
        }
      }

      newSlime.style.left = `${slimeX}px`;
      newSlime.style.top = `${slimeY}px`;

      slimes.push({
        element: newSlime,
        x: slimeX,
        y: slimeY,
        speed: baseEnemySpeed,
        targetX: slimeX,
        targetY: slimeY,
        movementMode: 'patrol',
        preferredSection: preferredSection,
        patrolCooldown: 0,
        chaseCooldown: 0,
        chaseDuration: 60 * 3,
        patrolDuration: 60 * 2,
        detectionRadius: 250
      });
    }

    function moveSlimesTowardsPlayer() {
      if (!gameStarted) return;

      slimes.forEach((slime) => {
        const prevSlimeX = slime.x;
        let currentSlimeSpeed = slime.speed;

        if (level >= 4 && level <= 6) {
          currentSlimeSpeed = slime.speed * (1 + (level - 3) * speedIncreasePerLevel);
        }

        const distToPlayer = Math.sqrt(Math.pow(playerX - slime.x, 2) + Math.pow(playerY - slime.y, 2));

        if (slime.movementMode === 'chasing') {
          slime.chaseCooldown--;
          if (slime.chaseCooldown <= 0 || distToPlayer > slime.detectionRadius * 1.5) {
            slime.movementMode = 'patrol';
            slime.patrolCooldown = 0;
          } else {
            slime.targetX = playerX;
            slime.targetY = playerY;
          }
        } else {
          if (distToPlayer < slime.detectionRadius) {
            slime.movementMode = 'chasing';
            slime.chaseCooldown = slime.chaseDuration;
            slime.targetX = playerX;
            slime.targetY = playerY;
          } else {
            slime.patrolCooldown--;
            if (slime.patrolCooldown <= 0 || (Math.abs(slime.x - slime.targetX) < 10 && Math.abs(slime.y - slime.targetY) < 10)) {
              slime.patrolCooldown = slime.patrolDuration;
              slime.targetX = Math.random() * (slime.preferredSection.maxX - slime.preferredSection.minX) + slime.preferredSection.minX;
              slime.targetY = Math.random() * (slime.preferredSection.maxY - slime.preferredSection.minY) + slime.preferredSection.minY;
            }
          }
        }

        const dx = slime.targetX - slime.x;
        const dy = slime.targetY - slime.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > 5) {
          slime.x += (dx / distance) * currentSlimeSpeed;
          slime.y += (dy / distance) * currentSlimeSpeed;

          const slimeHalfSize = 32;
          slime.x = Math.max(WORLD_BORDER_THICKNESS + slimeHalfSize, Math.min(slime.x, WORLD_WIDTH - WORLD_BORDER_THICKNESS - slimeHalfSize));
          slime.y = Math.max(WORLD_BORDER_THICKNESS + slimeHalfSize, Math.min(slime.y, WORLD_HEIGHT - WORLD_BORDER_THICKNESS - slimeHalfSize));

          slime.element.style.left = `${slime.x}px`;
          slime.element.style.top = `${slime.y}px`;

          slime.element.classList.add('enemy-moving');

          if (slime.x < prevSlimeX) {
            slime.element.classList.add('moving-left');
            slime.element.classList.remove('moving-right');
          } else if (slime.x > prevSlimeX) {
            slime.element.classList.add('moving-right');
            slime.element.classList.remove('moving-left');
          }
        } else {
          slime.element.classList.remove('enemy-moving');
        }

        if (checkCollision(playerX, playerY, 64, 64, slime.x, slime.y, 64, 64)) {
          resetGame();
          return;
        }
      });
    }

    function updateUI() {
      scoreValue.textContent = score;
      levelValue.textContent = level;
      fruitsText.textContent = `${fruitsCollectedInLevel}/${fruitToNextLevel}`;

      const progressPercentage = (fruitsCollectedInLevel / fruitToNextLevel) * 100;
      progressFill.style.width = `${progressPercentage}%`;

      updateParentScore();
    }

    function resetGame() {
      score = 0;
      level = 1;
      fruitsCollectedInLevel = 0;
      hasFruit = false;
      gameStarted = false;
      gameOver = false;

      slimes.forEach(slime => slime.element.remove());
      slimes.length = 0;

      const hutWidth = parseFloat(getComputedStyle(hut).width);
      const hutHeight = parseFloat(getComputedStyle(hut).height);

      hut.style.left = `${WORLD_WIDTH / 2}px`;
      hut.style.top = `${WORLD_HEIGHT / 2}px`;

      playerX = WORLD_WIDTH / 2;
      playerY = (WORLD_HEIGHT / 2) + (hutHeight / 2) + (64 / 2) + 10;

      sprite.style.left = `${playerX}px`;
      sprite.style.top = `${playerY}px`;

      addSlime();
      gameOverScreen.classList.add('hidden');
      instructions.classList.remove('hidden');

      setTimeout(() => {
        spawnFruit();
        updateScalingAndCamera();
        updateUI();
      }, 500);
    }

    // --- Función para procesar movimiento desde joystick ---
    function processJoystickMovement(relativeX, relativeY, speed) {
      // Convertir coordenadas del joystick a direcciones
      const threshold = 20; // Umbral mínimo para detectar movimiento

      // Limpiar todas las teclas
      keysPressed.w = false;
      keysPressed.s = false;
      keysPressed.a = false;
      keysPressed.d = false;

      if (speed > threshold) {
        // Determinar direcciones basadas en las coordenadas relativas
        if (Math.abs(relativeX) > Math.abs(relativeY)) {
          // Movimiento horizontal predominante
          if (relativeX > 0) {
            keysPressed.d = true; // Derecha
          } else {
            keysPressed.a = true; // Izquierda
          }
        } else {
          // Movimiento vertical predominante
          if (relativeY > 0) {
            keysPressed.s = true; // Abajo
          } else {
            keysPressed.w = true; // Arriba
          }
        }

        // Permitir movimiento diagonal si ambas coordenadas son significativas
        const diagonalThreshold = threshold * 0.7;
        if (Math.abs(relativeX) > diagonalThreshold && Math.abs(relativeY) > diagonalThreshold) {
          if (relativeX > 0) keysPressed.d = true;
          else keysPressed.a = true;
          if (relativeY > 0) keysPressed.s = true;
          else keysPressed.w = true;
        }
      }
    }

    function gameLoop() {
      if (gameOver) return;

      let moved = false;
      let newPlayerX = playerX;
      let newPlayerY = playerY;

      if (keysPressed.w || keysPressed.ArrowUp) {
        newPlayerY -= speed;
        lastDirection = 'up';
        moved = true;
      }
      if (keysPressed.s || keysPressed.ArrowDown) {
        newPlayerY += speed;
        lastDirection = 'down';
        moved = true;
      }
      if (keysPressed.a || keysPressed.ArrowLeft) {
        newPlayerX -= speed;
        lastDirection = 'left';
        moved = true;
      }
      if (keysPressed.d || keysPressed.ArrowRight) {
        newPlayerX += speed;
        lastDirection = 'right';
        moved = true;
      }

      if (moved && !gameStarted) {
        gameStarted = true;
        instructions.classList.add('hidden');
      }

      const playerHalfWidth = 64 / 2;
      const playerHalfHeight = 64 / 2;
      playerX = Math.max(WORLD_BORDER_THICKNESS + playerHalfWidth, Math.min(newPlayerX, WORLD_WIDTH - WORLD_BORDER_THICKNESS - playerHalfWidth));
      playerY = Math.max(WORLD_BORDER_THICKNESS + playerHalfHeight, Math.min(newPlayerY, WORLD_HEIGHT - WORLD_BORDER_THICKNESS - playerHalfHeight));

      sprite.style.left = `${playerX}px`;
      sprite.style.top = `${playerY}px`;

      updateScalingAndCamera();

      if (moved) {
        sprite.classList.add('walking');
        sprite.classList.remove('walking-up', 'walking-down', 'walking-right');
        switch (lastDirection) {
          case 'up':
            sprite.classList.add('walking-up');
            break;
          case 'down':
            sprite.classList.add('walking-down');
            break;
          case 'left':
            sprite.classList.add('walking-right');
            sprite.style.transform = 'translate(-50%, -50%) scaleX(-1)';
            break;
          case 'right':
            sprite.classList.add('walking-right');
            sprite.style.transform = 'translate(-50%, -50%) scaleX(1)';
            break;
        }
      } else {
        sprite.classList.remove('walking');
      }

      moveSlimesTowardsPlayer();

      if (hasFruit) {
        fruit.style.left = `${playerX}px`;
        fruit.style.top = `${playerY - 32}px`;

        const hutX = parseFloat(hut.style.left);
        const hutY = parseFloat(hut.style.top);

        if (checkCollision(playerX, playerY, 64, 64, hutX, hutY, 95.4, 128)) {
          hasFruit = false;
          fruit.style.display = 'none';
          score++;
          fruitsCollectedInLevel++;

          if (fruitsCollectedInLevel >= fruitToNextLevel && level < maxSlimes) {
            level++;
            fruitsCollectedInLevel = 0;
            addSlime();
            notifyGameWin();
          }

          updateUI();

          if (level >= maxSlimes && fruitsCollectedInLevel >= fruitToNextLevel) {
            gameOver = true;
            notifyGameWin();
            gameOverScreen.classList.remove('hidden');
          } else {
            setTimeout(spawnFruit, 500);
          }
        }
      } else {
        const fruitX = parseFloat(fruit.style.left);
        const fruitY = parseFloat(fruit.style.top);

        if (fruit.style.display !== 'none' &&
          checkCollision(playerX, playerY, 64, 64, fruitX, fruitY, 53.2, 55.3)) {
          hasFruit = true;
        }
      }

      requestAnimationFrame(gameLoop);
    }

    // --- Event Listeners ---
    document.addEventListener('keydown', (e) => {
      keysPressed[e.key] = true;
    });

    document.addEventListener('keyup', (e) => {
      keysPressed[e.key] = false;
    });

    window.addEventListener('resize', () => {
      updateScalingAndCamera();
      updateUI();
    });

    restartButton.addEventListener('click', () => {
      resetGame();
    });

    // --- Función para detectar si es dispositivo táctil ---
    function isTouchDevice() {
      return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    }

    // --- Configuración de controles móviles ---
    function setupMobileControls() {
      console.log('Setting up mobile controls...');
      console.log('Is touch device:', isTouchDevice());

      const mobileControls = document.getElementById('mobile-controls');
      const toggleBtn = document.getElementById('toggle-controls-btn');

      if (isTouchDevice()) {
        // DISPOSITIVO TÁCTIL (móvil/tablet) - Mostrar controles siempre
        console.log('Touch device detected - showing mobile controls');

        if (mobileControls) {
          mobileControls.style.display = 'block';
          mobileControls.classList.remove('hidden');
        }

        // Ocultar botón de toggle (no se necesita)
        if (toggleBtn) {
          toggleBtn.style.display = 'none';
        }

        // Configurar controles táctiles
        setupControlSwitching();
        setupDpad();
        setupJoystick();

      } else {
        // DISPOSITIVO NO TÁCTIL (PC) - Ocultar todo, usar solo teclado
        console.log('Non-touch device detected - hiding mobile controls, using keyboard only');

        if (mobileControls) {
          mobileControls.style.display = 'none';
        }

        if (toggleBtn) {
          toggleBtn.style.display = 'none';
        }
      }
    }

    // Función separada para configurar el switch entre D-pad y Joystick
    function setupControlSwitching() {
      const controlToggle = document.getElementById('control-toggle');
      const dpadControls = document.getElementById('dpad-controls');
      const joystickControls = document.getElementById('joystick-controls');

      if (controlToggle) {
        controlToggle.addEventListener('click', () => {
          isDpadMode = !isDpadMode;
          controlToggle.classList.toggle('active', !isDpadMode);

          if (isDpadMode) {
            dpadControls.style.display = 'flex';
            joystickControls.style.display = 'none';
          } else {
            dpadControls.style.display = 'none';
            joystickControls.style.display = 'flex';
            setupJoystick();
          }
        });
      }
    }

    function setupDpad() {
      const buttons = document.querySelectorAll('.dpad-button');
      const keyMap = {
        up: 'w',
        down: 's',
        left: 'a',
        right: 'd'
      };

      buttons.forEach(button => {
        const key = keyMap[button.id];

        button.addEventListener('touchstart', (e) => {
          e.preventDefault();
          keysPressed[key] = true;
        }, {
          passive: false
        });

        button.addEventListener('touchend', (e) => {
          e.preventDefault();
          keysPressed[key] = false;
        });

        button.addEventListener('touchcancel', (e) => {
          e.preventDefault();
          keysPressed[key] = false;
        });
      });
    }

    function setupJoystick() {
      const canvas = document.getElementById('joystick-canvas');
      if (!canvas) return;

      const ctx = canvas.getContext('2d');

      // Ajustar tamaño a 200px
      let width = 200;
      let height = 200;
      let radius = 70; // Reducido proporcionalmente de 100 a 70
      let x_orig = width / 2; // 100
      let y_orig = height / 2; // 100

      canvas.width = width;
      canvas.height = height;

      function drawBackground() {
        ctx.clearRect(0, 0, width, height);
        ctx.beginPath();
        ctx.arc(x_orig, y_orig, radius + 15, 0, Math.PI * 2, true); // Reducido de +20 a +15
        ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 2; // Reducido de 3 a 2
        ctx.stroke();
      }

      function drawJoystick(x, y) {
        ctx.beginPath();
        ctx.arc(x, y, radius * 0.5, 0, Math.PI * 2, true); // Reducido de 0.6 a 0.5
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(200, 200, 200, 0.9)';
        ctx.lineWidth = 3; // Reducido de 4 a 3
        ctx.stroke();
      }

      let coord = {
        x: 0,
        y: 0
      };
      let paint = false;

      function getPosition(event) {
        const rect = canvas.getBoundingClientRect();
        const clientX = event.clientX || (event.touches && event.touches[0].clientX);
        const clientY = event.clientY || (event.touches && event.touches[0].clientY);
        coord.x = clientX - rect.left;
        coord.y = clientY - rect.top;
      }

      function isInCircle() {
        const current_radius = Math.sqrt(Math.pow(coord.x - x_orig, 2) + Math.pow(coord.y - y_orig, 2));
        return radius >= current_radius;
      }

      function startDrawing(event) {
        event.preventDefault();
        paint = true;
        joystickActive = true;
        getPosition(event);
        if (isInCircle()) {
          drawBackground();
          drawJoystick(coord.x, coord.y);
        }
      }

      function stopDrawing(event) {
        event.preventDefault();
        paint = false;
        joystickActive = false;
        drawBackground();
        drawJoystick(x_orig, y_orig);

        // Limpiar todas las teclas cuando se suelta el joystick
        keysPressed.w = false;
        keysPressed.s = false;
        keysPressed.a = false;
        keysPressed.d = false;
      }

      function draw(event) {
        if (paint) {
          event.preventDefault();
          getPosition(event);

          let x, y;
          if (isInCircle()) {
            x = coord.x;
            y = coord.y;
          } else {
            const angle = Math.atan2((coord.y - y_orig), (coord.x - x_orig));
            x = radius * Math.cos(angle) + x_orig;
            y = radius * Math.sin(angle) + y_orig;
          }

          drawBackground();
          drawJoystick(x, y);

          // Calcular movimiento
          const x_relative = Math.round(x - x_orig);
          const y_relative = Math.round(y - y_orig);
          const speed = Math.round(100 * Math.sqrt(Math.pow(x - x_orig, 2) + Math.pow(y - y_orig, 2)) / radius);

          // Procesar movimiento
          processJoystickMovement(x_relative, y_relative, speed);
        }
      }

      // Event listeners para el joystick
      canvas.addEventListener('touchstart', startDrawing, {
        passive: false
      });
      canvas.addEventListener('touchend', stopDrawing, {
        passive: false
      });
      canvas.addEventListener('touchcancel', stopDrawing, {
        passive: false
      });
      canvas.addEventListener('touchmove', draw, {
        passive: false
      });

      // También agregar soporte para mouse (para testing en desktop)
      canvas.addEventListener('mousedown', startDrawing);
      canvas.addEventListener('mouseup', stopDrawing);
      canvas.addEventListener('mousemove', draw);
      canvas.addEventListener('mouseleave', stopDrawing);

      // Dibujar estado inicial
      drawBackground();
      drawJoystick(x_orig, y_orig);
    }

    // --- Inicializar juego ---
    console.log('Initializing game...');
    initializeGame();
    setupMobileControls();
    gameLoop();
    console.log('Game initialized');
  </script>
</body>

</html>
